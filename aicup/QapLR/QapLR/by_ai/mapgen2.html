<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Сбалансированная карта: без диагонального леса</title>
  <style>
    body { margin: 20px; font-family: sans-serif; background: #fafafa; }
    canvas { border: 1px solid #666; background: white; image-rendering: pixelated; }
    button { margin: 5px; padding: 6px 10px; }
  </style>
</head>
<body>
  <h3>Сбалансированная генерация (без перекоса к диагоналям)</h3>
  <button onclick="generateMap('mirror')">Зеркало</button>
  <button onclick="generateMap('rotate')">Поворот</button>
  <button onclick="generateHeatmap(100)">Heatmap (100)</button>
  <canvas id="c" width="800" height="800"></canvas>

  <script>
    const SIZE = 80;
    const HALF = 40;
    const SAFE = 0;
    const N = SIZE - 1;

    // --- Все вспомогательные функции (без изменений) ---
    function createQuarter() {
      return Array(HALF).fill().map(() => Array(HALF).fill(0));
    }
    function safeSet(q, x, y, v) {
      if (x < SAFE && y < SAFE) return;
      if (x >= 0 && x < HALF && y >= 0 && y < HALF) q[y][x] = v;
    }
    function drawBlob(q, cx, cy, r, v) {
      const r2 = r * r;
      for (let dy = -r; dy <= r; dy++)
        for (let dx = -r; dx <= r; dx++)
          if (dx*dx + dy*dy <= r2) safeSet(q, cx+dx, cy+dy, v);
    }
    function addRandomNoise(q, p = 0.03) {
      for (let y = 0; y < HALF; y++)
        for (let x = 0; x < HALF; x++)
          if ((x >= SAFE || y >= SAFE) && Math.random() < p)
            q[y][x] = 1 - q[y][x];
    }
    function addGeometricNoise(q) {
      const f = 20 + Math.floor(Math.random() * 20);
      for (let i = 0; i < f; i++) {
        let x = Math.floor(Math.random() * (HALF - 2));
        let y = Math.floor(Math.random() * (HALF - 2));
        if (x < SAFE && y < SAFE) continue;
        const t = Math.floor(Math.random() * 4);
        if (t === 0) for (let dy=0;dy<2;dy++) for (let dx=0;dx<2;dx++) safeSet(q,x+dx,y+dy,1);
        else if (t === 1) [[0,1],[1,0],[1,1],[1,2],[2,1]].forEach(([dy,dx])=>safeSet(q,x+dx-1,y+dy-1,1));
        else if (t === 2) for (let dx=0;dx<3;dx++) safeSet(q,x+dx,y,1);
        else for (let dy=0;dy<3;dy++) safeSet(q,x,y+dy,1);
      }
    }
    function drawLocalPath(q, sx, sy, len = 12) {
      let x = sx, y = sy;
      for (let i = 0; i < len; i++) {
        if (x < SAFE && y < SAFE) break;
        const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
        const [dx,dy] = dirs[Math.floor(Math.random()*dirs.length)];
        const nx = x+dx, ny = y+dy;
        if (nx >= SAFE && nx < HALF-1 && ny >= 0 && ny < HALF-1) {
          x = nx; y = ny;
          q[y][x] = 0;
        }
      }
    }

    // --- ИСПРАВЛЕННАЯ ГЕНЕРАЦИЯ ЧЕТВЕРТИ ---
    function generateQuarter(addPaths = false, addGeoNoise = false) {
      const q = createQuarter();addPaths = 1, addGeoNoise = 1;
      const clusters = 4 + Math.floor(Math.random() * 10); // 14–24

      for (let i = 0; i < clusters; i++) {
        let x, y;
        let attempts = 0;
        do {
          x = SAFE + 2 + Math.floor(Math.random() * (HALF - SAFE - 4));
          y = SAFE + 2 + Math.floor(Math.random() * (HALF - SAFE - 4));
          attempts++;
        } while (attempts < 30 && Math.abs(x - y) < 5 && Math.random() < 0.7);

        const r = 2 + Math.floor(Math.random() * 5); // 2–6
        drawBlob(q, x, y, r, 1);
      }

      addRandomNoise(q, 0.13);
      if (addGeoNoise) addGeometricNoise(q);
      if (addPaths) {
        const paths = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < paths; i++) {
          let sx, sy;
          if (Math.random() < 0.5) {
            sx = HALF - 8 + Math.floor(Math.random() * 6);
            sy = SAFE + 4 + Math.floor(Math.random() * (HALF - SAFE - 8));
          } else {
            sx = SAFE + 4 + Math.floor(Math.random() * (HALF - SAFE - 8));
            sy = HALF - 8 + Math.floor(Math.random() * 6);
          }
          drawLocalPath(q, sx, sy, 10 + Math.floor(Math.random() * 8));
        }
      }
      return q;
    }

    // --- Симметрии (без изменений) ---
    function applyMirror(q) {
      const g = new Array(SIZE*SIZE).fill(0);
      for (let y=0; y<HALF; y++) for (let x=0; x<HALF; x++) {
        const v = q[y][x];
        g[y*SIZE+x] = v;
        g[y*SIZE+(N-x)] = v;
        g[(N-y)*SIZE+x] = v;
        g[(N-y)*SIZE+(N-x)] = v;
      }
      return g;
    }
    function applyRotation(q) {
      const g = new Array(SIZE*SIZE).fill(0);
      for (let y=0; y<HALF; y++) for (let x=0; x<HALF; x++) {
        const v = q[y][x];
        g[y*SIZE+x] = v;
        g[(N-x)*SIZE+y] = v;
        g[(N-y)*SIZE+(N-x)] = v;
        g[x*SIZE+(N-y)] = v;
      }
      return g;
    }

    // --- Heatmap ---
    function generateHeatmap(iters = 100) {
      const sum = new Array(SIZE*SIZE).fill(0);
      for (let i = 0; i < iters; i++) {
        const q = generateQuarter(false, false);
        const map = applyMirror(q); // или rotate
        for (let j = 0; j < SIZE*SIZE; j++) sum[j] += map[j];
      }
      const hm = sum.map(v => 255 - Math.round((v / iters) * 255));
      draw(hm, true);
    }

    // --- Визуализация ---
    function draw(grid, isHeatmap = false) {
      const c = document.getElementById('c');
      const ctx = c.getContext('2d');
      const s = 800 / SIZE;
      for (let y = 0; y < SIZE; y++)
        for (let x = 0; x < SIZE; x++) {
          const val = grid[y*SIZE + x];
          if (isHeatmap) {
            ctx.fillStyle = `rgb(${val},${val},${val})`;
          } else {
            ctx.fillStyle = val ? 'black' : 'white';
          }
          ctx.fillRect(x*s, y*s, s, s);
        }
    }

    function generateMap(sym) {
      const q = generateQuarter(false, false);
      const map = sym === 'rotate' ? applyRotation(q) : applyMirror(q);
      draw(map, false);
    }

    generateMap('mirror');
  </script>
</body>
</html>