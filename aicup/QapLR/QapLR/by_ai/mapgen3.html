<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Острова как многоугольники</title>
  <style>
    body { margin: 20px; font-family: sans-serif; }
    canvas { border: 1px solid #888; background: white; image-rendering: pixelated; }
    button { margin: 5px; padding: 6px 12px; }
  </style>
</head>
<body>
  <h3>Многоугольные острова + органические тропинки</h3>
  <button onclick="generateMap()">Сгенерировать</button>
  <canvas id="c" width="800" height="800"></canvas>

  <script>
    const SIZE = 80;
    const HALF = 40;
    const N = SIZE - 1;
    const USE_PATHS_PROB = 0.75;
    const SYMMETRY_MODES = ['mirror', 'rotate'];

    // --- Вспомогательные функции ---
    function createQuarter() {
      return Array(HALF).fill().map(() => Array(HALF).fill(0));
    }

    function setInQuarter(q, x, y, v) {
      if (x >= 0 && x < HALF && y >= 0 && y < HALF) q[y][x] = v;
    }

    // Проверка, находится ли точка внутри многоугольника (алгоритм луча)
    function pointInPolygon(x, y, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i][0], yi = poly[i][1];
        const xj = poly[j][0], yj = poly[j][1];
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Генерация и заливка многоугольного "острова"
    function drawPolygonBlob(q, cx, cy, minR = 3, maxR = 10, sides = 6) {
      // Генерируем углы
      const angles = [];
      for (let i = 0; i < sides; i++) {
        angles.push((Math.PI * 2 * i) / sides + (Math.random() - 0.5) * 0.8); // небольшой шум
      }
      angles.sort((a, b) => a - b);

      // Генерируем вершины
      const poly = [];
      for (const a of angles) {
        const r = minR + Math.random() * (maxR - minR);
        const px = cx + Math.cos(a) * r;
        const py = cy + Math.sin(a) * r;
        poly.push([px, py]);
      }

      // Находим bounding box
      const xs = poly.map(p => p[0]);
      const ys = poly.map(p => p[1]);
      const minX = Math.max(0, Math.floor(Math.min(...xs)) - 1);
      const maxX = Math.min(HALF - 1, Math.ceil(Math.max(...xs)) + 1);
      const minY = Math.max(0, Math.floor(Math.min(...ys)) - 1);
      const maxY = Math.min(HALF - 1, Math.ceil(Math.max(...ys)) + 1);

      // Заливаем все клетки внутри
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          if (pointInPolygon(x + 0.5, y + 0.5, poly)) {
            setInQuarter(q, x, y, 1);
          }
        }
      }

      // Дополнительный шум по краю для "рваности"
      if (Math.random() < 0.5) {
        for (let y = minY; y <= maxY; y++) {
          for (let x = minX; x <= maxX; x++) {
            if (q[y][x] === 1) {
              // Проверим соседей: если есть пустой — с вероятностью удалим
              let neighbors = 0;
              for (let dy = -1; dy <= 1; dy++)
                for (let dx = -1; dx <= 1; dx++)
                  if (q[y + dy] && q[y + dy][x + dx] === 1) neighbors++;
              if (neighbors < 5 && Math.random() < 0.2) {
                setInQuarter(q, x, y, 0);
              }
            }
          }
        }
      }
    }

    // Органическая тропинка: случайное блуждание из центра к границе
    function drawOrganicPath(q, startX, startY) {
      let x = startX, y = startY;
      const steps = 15 + Math.floor(Math.random() * 15);
      for (let i = 0; i < steps; i++) {
        setInQuarter(q, x, y, 0);
        // Выбираем направление: с лёгким смещением к границе
        const dx = (x < HALF - 5 && Math.random() < 0.6) ? 1 : (x > 5 ? -1 : 0);
        const dy = (y < HALF - 5 && Math.random() < 0.6) ? 1 : (y > 5 ? -1 : 0);
        // Добавим случайности
        const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
        const [rdx, rdy] = dirs[Math.floor(Math.random() * dirs.length)];
        x += Math.random() < 0.3 ? rdx : dx;
        y += Math.random() < 0.3 ? rdy : dy;
        if (x < 0 || x >= HALF || y < 0 || y >= HALF) break;
      }
    }

    // --- Генерация четверти ---
    function generateQuarter() {
      const q = createQuarter();

      // Многоугольные острова
      const clusters = 10 + Math.floor(Math.random() * 12);
      for (let i = 0; i < clusters; i++) {
        const cx = Math.floor(Math.random() * HALF);
        const cy = Math.floor(Math.random() * HALF);
        // Избегаем сильного скопления на диагонали
        if (Math.abs(cx - cy) < 4 && Math.random() < 0.6) continue;
        const minR = 2 + Math.floor(Math.random() * 3);
        const maxR = minR + 3 + Math.floor(Math.random() * 5);
        const sides = 5 + Math.floor(Math.random() * 5); // 5–9 сторон
        drawPolygonBlob(q, cx, cy, minR, maxR, sides);
      }

      // Фоновый шум
      for (let y = 0; y < HALF; y++)
        for (let x = 0; x < HALF; x++)
          if (Math.random() < 0.03) q[y][x] = 1 - q[y][x];

      // 75%: органические тропинки из центра
      if (Math.random() < USE_PATHS_PROB) {
        const cx = 18 + Math.floor(Math.random() * 5);
        const cy = 18 + Math.floor(Math.random() * 5);
        const paths = 1 + (Math.random() < 0.4 ? 1 : 0);
        for (let p = 0; p < paths; p++) {
          drawOrganicPath(q, cx, cy);
        }
      }

      return q;
    }

    // --- Симметрии ---
    function applyMirror(q) {
      const g = new Array(SIZE * SIZE).fill(0);
      for (let y = 0; y < HALF; y++)
        for (let x = 0; x < HALF; x++) {
          const v = q[y][x];
          g[y * SIZE + x] = v;
          g[y * SIZE + (N - x)] = v;
          g[(N - y) * SIZE + x] = v;
          g[(N - y) * SIZE + (N - x)] = v;
        }
      return g;
    }

    function applyRotation(q) {
      const g = new Array(SIZE * SIZE).fill(0);
      for (let y = 0; y < HALF; y++)
        for (let x = 0; x < HALF; x++) {
          const v = q[y][x];
          g[y * SIZE + x] = v;
          g[(N - x) * SIZE + y] = v;
          g[(N - y) * SIZE + (N - x)] = v;
          g[x * SIZE + (N - y)] = v;
        }
      return g;
    }

    // --- Генерация и отрисовка ---
    function generateMap() {
      const quarter = generateQuarter();
      const symmetry = SYMMETRY_MODES[Math.floor(Math.random() * SYMMETRY_MODES.length)];
      const fullMap = symmetry === 'rotate' ? applyRotation(quarter) : applyMirror(quarter);
      draw(fullMap);
      console.log(`Симметрия: ${symmetry}`);
    }

    function draw(grid) {
      const c = document.getElementById('c');
      const ctx = c.getContext('2d');
      const s = 800 / SIZE;
      for (let y = 0; y < SIZE; y++)
        for (let x = 0; x < SIZE; x++) {
          ctx.fillStyle = grid[y * SIZE + x] ? 'black' : 'white';
          ctx.fillRect(x * s, y * s, s, s);
        }
    }

    generateMap();
  </script>
</body>
</html>